Решение:

1. Создаётся `FixedThreadPool` размером `n = availableProcessors`
2. В нём запускается одна таска которая добавляет новые `news id` в очередь `newsQueue`
3. И запускается `n - 1` тасок воркеров
4. Воркеры разгребают очереди `newsQueue` и `sentenceQueue`, из `newsQueue` достаётся id статьи, извлекается текст и помещается в `sentenceQueue`, откуда он попадает на оценку сентимента. В первую очередь обрабатывается `sentenceQueue` т.к. оценка сентимента медленнее. 
5. `newsQueue` - это `blocking queue` и её размер ограничен самой структурой данных, что исключает переполнение при заполнении, это работает потому что пишет и читают из неё гарантированно разные воркеры.
6. `sentenceQueue` - это `concurrent queue`, её размер ограничивается нестрого, каждый воркер проверяет лимит сам, в итоге туда может попасть чуть больше элементов чем задано лимитом, но это позволяет всем воркерам одновременно и добавлять туда элементы и извлекать их оттуда. Если здесь использовать `blocking queue`, то это может привести к взаимной блокировке когда все воркеры будут висеть в блокировке при попытке записать в переполненную очередь и ни один не будет пытаться достать оттуда элементы.

В итоге все воркеры максимально эффективно утилизируют выданный им thread pool.

По парсингу упарываться не стал, прогнал 500 последних новостей вышло:
```
usa=Stats{mentions=5, score=-13, rating=-2.166}
java=Stats{mentions=2, score=-2, rating=-0.66}
kotlin=Stats{mentions=2, score=-1, rating=-0.33}
python=Stats{mentions=1, score=-1, rating=-0.5}
```

Выводы:

- В Америке житие тяжелоё, не поедем туда
- Java явно популярнее Python, но Python лучше!
- А Kotlin вообще богом данная нам технология
